def evaluate_model_GSA(solution):
    num_layers, num_neurons = solution
    num_layers = max(1, round(num_layers))  # Garante que o número de camadas é pelo menos 1 e é um número arredondado
    num_neurons = max(1, round(num_neurons))  # Garante que o número de neurônios é pelo menos 1 e é um número arredondado

    activation_function = 'elu'  # ou escolha a função de ativação desejada
    learning_rate = 0.001

    model = keras.Sequential([
        keras.layers.Flatten(input_shape=(64, 64, 3)),
    ])

    for _ in range(num_layers):
        model.add(keras.layers.Dense(num_neurons, activation=activation_function))

    model.add(keras.layers.Dense(8, activation='softmax'))

    optimizer = keras.optimizers.Adam(learning_rate=learning_rate)
    
    try:
        model.compile(optimizer=optimizer, loss='sparse_categorical_crossentropy', metrics=['accuracy'])

        history = model.fit(x_train[:50], y_train[:50], epochs=5, validation_data=(x_validation[:25], y_validation[:25]), verbose=0)
        y_pred = np.argmax(model.predict(x_test[:25]), axis=1)
        accuracy = accuracy_score(y_test[:25], y_pred)

        return 1 - accuracy  # O GSA minimiza a função, então usamos 1 - accuracy
    except tf.errors.ResourceExhaustedError:
        # Em caso de falta de memória, retorne um custo alto
        return 1e6
    agents += forces

    # Avaliação das soluções
    costs = np.array([evaluate_model_GSA(agent) for agent in agents])